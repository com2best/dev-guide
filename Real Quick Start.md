

# 1시간 만에 챗봇 만들기(초급)
---
1시간 만에 챗봇 만들기(초급)에서는 PlayChat 플랫폼을 사용하여 챗봇을 만드는 방법에 대한 단계별 가이드를 제공합니다.
가이드를 그대로 따라가세요. 1시간 만에 챗봇이 만들어 집니다!

## Step 1 : 챗봇 생성하기
처음 PlayChat에 접속하셨다면, 회원가입을 진행합니다.

//회원가입화면

로그인시 계정이 소유한 챗봇 목록을 보여줍니다. 아직은 챗봇이 없습니다. 새로운 챗봇을 만들기 위해 **새 봇 만들기** 버튼을 클릭합니다.

//플레이챗 봇 목록 화면

챗봇은 빈 봇 혹은 샘플 봇으로 만들 수 있습니다. **샘플봇**의 경우, 플레이챗이 제공하는 각종 기능에 대한 기능가이드 챗봇, 업종별 맞춤 기능이 구현된 업종샘플봇이 있습니다. 

챗봇의 다양한 기능과 구성방식을 알아보기 위해 **기능가이드 챗봇**을 만들어보겠습니다.

**샘플봇 만들기**를 클릭하고 챗봇의 이름, 챗봇에 관한 설명, 샘플봇 종류  그리고 챗봇이 사용할 언어를 선택하고 **만들기** 버튼을 누릅니다.

//챗봇 이름 입력 화면

챗봇이 만들어 졌습니다. 챗봇 개발 페이지의 대시보드에서 챗봇 프로필을 볼 수 있습니다.


## Step 2 : 대화 시나리오 살펴보기
이제 Step 1에서 만든 챗봇의 대화 시나리오를 개발하기 위해 왼쪽 네비게이션 바의 **개발** => **대화 시나리오** 메뉴를 클릭합니다.

//네비게이션 화면

핵심 개념 : 카드, 부모 카드, 자식 카드, 커서
핵심 개념 : 사용자 입력, 챗봇 답변 
핵심 개념 : 실행, 검색, 매칭

### 대화카드 (카드)

챗봇 개발 화면을 보면 네모난 박스들이 연결되어 있는 것을 확인할 수 있습니다. 이 네모 박스 하나를 **카드**라고 말합니다. 하나의 **카드**는 기본적으로 카드 이름, 사용자 입력, 챗봇 답변으로 이루어져 있습니다. **카드**를 더블 클릭하면 오른쪽에 카드 수정창이 등장합니다.

**카드이름**은 해당 카드를 지칭하는 이름으로써 카드들에 대한 식별자 역할을 하기에 중복된 이름을 사용할 수 없습니다. 


**사용자 입력**은 사용자들이 어떤 말을 입력했을 때 해당 카드가 실행될 지 여부를 결정하는 조건 입력란 입니다. 예를 들어, **사용자 입력**에 '안녕'이라고 입력했다면 사용자가 '안녕'이라고 입력하는 순간 해당 카드가 실행됩니다.

시작 카드의 **사용자 입력**에는 3개의 값(시작, 처음, start)이 있습니다. 여러가지 값이 사용자 입력에 놓여 있을 경우, 어떤 값을 사용자가 입력해도 **시작 카드**는 실행됩니다. 즉, 시작, 처음 또는 start 중 어느 것을 사용자가 입력해도 **시작 카드**가 실행됩니다(오른쪽 테스트 콘솔에서 확인해보세요).

+버튼을 눌러 사용자 입력을 추가하고, 휴지통 버튼을 눌러 사용자 입력을 삭제할 수 있습니다.

사용자 입력에 새로운 값을 입력할 때 입력창 아래 작은 글씨로 nlu라는 글씨가 보입니다. nlu는 Natural Language Understanding(자연어 이해)의 약자로, 사용자 입력에 입력된 자연어를 실시간으로 챗봇이 이해할 수 있는 언어로 변환한 결과를 보여줍니다. 예를 들어, 사용자 입력에 '처음으로 돌아가'라고 입력했을 경우, nlu 엔진에 의해 해당 값은 '처음 돌아가다'로 입력됩니다.


**챗봇 답변**은 해당 카드가 실행됐을 때 챗봇이 내놓을 답변입니다. 예를 들어 **챗봇 답변**에 '반가워'라고 입력했다면, 해당 카드가 실행됐을 때 챗봇은 '반가워'라고 답변합니다.

시작 카드의 **챗봇 답변**에는 챗봇의 인사말과 함께 자기소개가 입력되어 있습니다. 챗봇이 텍스트로 답변하길 원할 경우, **텍스트**만 입력하고, 좀 더 생생한 브랜드 이미지를 전달하기 위해서는 **이미지**를 사용할 수 있습니다. 또한 챗봇 사용자들의 답변 입력을 편리화하기 위해 카드에 **버튼**을 달 수도 있습니다. 버튼의 경우, 단순한 답변을 위한 버튼일 수도 있지만 URL값을 입력하면 특정 URL로 연결되는 **링크 버튼**을 만들 수도 있습니다. **대화 흐름 조절**은 커서의 이동을 설정하는 기능입니다. 기본적으로 커서는 부모 카드에서 자식 카드로 이동합니다. 커서를 임의의 다른 카드로 이동하고 싶을 때 **대화 흐름 조절**을 이용할 수 있습니다. (더 자세한 설명은 구체적인 예시와 함께 살펴보겠습니다.)

만약 시작 대화가 실행됐을 때 **챗봇 답변**을 다양하게 하려면 어떻게 해야될까요? 간단하게 챗봇 답변을 추가해주면 됩니다. +버튼을 누르면 비어있는 챗봇 답변이 추가 됩니다. 텍스트, 이미지, 버튼 중 원하는 것을 입력하면 대화 카드가 실행됐을 때 2가지 챗봇 답변 중 랜덤으로 답변하게 됩니다. 지금 바로 챗챗봇 답변을 추가하거나 삭제해보세요!

카드 이름, 사용자 입력, 챗봇 답변들이 모여 하나의 카드를 만들고, 카드들이 연결되어 하나의 시나리오를 구성합니다. 그리고 시나리오들이 모여 하나의 챗봇을 구성합니다.

### 시작 카드

**시작 카드**는 모든 시나리오 그래프의 시작점입니다. 사용자가 챗봇과 처음 접촉했을 때 실행되는 카드이자 사용자가 시나리오의 첫 단계로 돌아갈 때 실행되는 카드이기도 합니다. *시작 카드*를 더블 클릭 하겠습니다.

지금까지 시작 대화에 입력된 이름, 사용자 입력, 챗봇 답변을 살펴봤습니다. 아직 대화 카드의 **Advanced** 기능은 살펴보지 않았는데요, 인공지능이 들어간 심화 기능을 이용하고 싶다면 중급자 코스를 살펴보세요!

### 대화 카드 간의 연결 1 - 부모와 자식

챗봇이 다양한 기능과 대화를 수행하기 위해서는 하나의 대화카드로는 부족합니다. 따라서 여러개의 대화 카드를 만들고 각각을 연결할 필요가 있습니다. 두 개의 대화카드를 연결할 때 가장 기본적인 연결은 *부모-자식* 간의 연결입니다. *부모-자식* 간의 연결이란 시작 대화 카드와 인사 대화 카드의 연결처럼 직접적 상하관계의 카드 연결을 의미합니다. 예를 들어, 인사 대화 카드 오른쪽에 대화 카드를 하나 추가하면 새로운 대화 카드는 인사 대화 카드와 *부모-자식* 관계로 연결됩니다.

부모-자식 연결 상에서 사용자 입력-챗봇 답변 관계를 살펴보겠습니다. 부모의 대화 카드가 실행되면 챗봇은 부모의 챗봇 답변을 출력하고 사용자의 입력을 기다립니다. 이 때 사용자의 입력값이 자식 대화 카드의 **사용자 입력**에 부합할 때 자식 대화 카드는 실행됩니다. 그리고 만약 사용자의 입력값이 자식 대화 카드의 **사용자 입력**에 부합하지 않는다면 챗봇은 '알아듣지 못했습니다'라고 답변합니다. 사용자의 입력값에 부합하는 자식 대화 카드가 없기 때문입니다. 그렇다면 자식 대화 카드를 여러개 만들면 되지 않을까요? 하나의 부모에 여러 자식 대화 카드가 연결되었을 때 어떻게 챗봇이 동작하지는 시작 대화 카드를 통해 구체적으로 살펴보겠습니다.

> 부모의 챗봇 답변 -> 사용자의 입력 -> 자식의 사용자 입력과의 부합 여부

### 시작 대화 카드와 그 자식들

  시작 대화 카드의 자식들을 살펴보겠습니다. 시작 대화 카드와 연결되어 있으면 부모-자식 관계를 맺고 있는 대화 카드는 총 8개가 있습니다. 이렇듯 하나의 부모 대화 카드에 여러개의 자식 대화 카드가 연결되어 있을 경우, 대화 시나리오는 어떻게 진행될까요?

  플레이 아웃도어 챗봇에게 '안녕'이라고 입력해보겠습니다. 챗봇이 '안녕하세요'라고 답변하네요. 이번에는 '이름이 뭐야?'라고 입력해보겠습니다.  자기 이름을 말해줍니다. 사용자의 입력이 첫 번째 자식 대화 카드(자식들 중 가장 상위에 있는 대화 카드)의 **사용자 입력**에 부합할 경우 첫 번째 자식 대화가 실행되며, 그렇지 않을 경우 두 번째 자식 대화 카드의 **사용자 입력**과 부합하는지 따져봅니다. 만약 부합할 경우 두 번째 자식 대화 카드가 실행되며 그렇지 않을 경우 그 다음 대화 카드의 **사용자 입력**과 부합하는지 따져봅니다. 이렇듯 하나의 부모에 여러 자식 대화 카드가 연결되어 있을 경우, 상위의 자식 대화 카드부터 시작해 가장 하위에 있는 자식 대화 카드까지 **사용자 입력**이 사용자의 입력값과 부합하는지 따져봅니다. 모든 자식 대화 카드의 **사용자 입력**이 사용자의 입력값과 일치하지 않는다면 그 때 챗봇은 '알아듣지 못했습니다'라는 답변을 출력합니다. 즉, 사용자의 입력에 부합하는 자식 대화 카드를 찾지 못했기 때문에 챗봇은 알아듣지 못했다는 답변을 내놓습니다.
  중요한 점은 자식 대화 카드 간의 순서가 존재하고, 대화 카드의 실행여부를 그 순서대로 판단한다는 점입니다. 따라서 비슷한 **사용자 입력** 을 갖고 있는 자식 대화 카드들이 있다면 가장 상위에 있는 대화 카드가 실행됨을 기억해야 합니다.

 지금부터는 시작 대화 카드의 자식 대화 카드들을 살펴보면서 각 자식 별로 해당 대화 카드의 기능이 무엇인지 살펴보겠습니다.

### 인사 대화 카드 - 뎁스(Depth)와 커서(Cursor)

첫 번째 자식은 인사 대화 카드입니다. 시작 대화 카드에서 사용자가 인사말을 건넬 때 실행되는 대화 카드 입니다. 가장 상위에 있기 때문에 시작 대화 카드의 모든 자식들 중 가장 먼저 부합 여부를 판단하는 대화 카드입니다. 인사 대화 카드는 '안녕', '하이'와 같은 사용자 입력이 들어오면 실행되는 단순한 대화 카드입니다.

여기서 살펴볼 것은 **뎁스** 개념입니다. 챗봇을 고도화하면 할수록 대화 카드들 간의 부모-자식 연결은 길어지고 그에 따라 뎁스가 생깁니다. 예를 들어, 시작 대화 카드의 경우 그 뎁스가 0이고 인사 대화 카드의 경우 뎁스가 1입니다. 그 뒤에 자식 대화 카드가 계속 연결되면 뎁스가 2, 3, 4 등으로 깊어집니다.

한편 **커서**는 마지막으로 실행된 대화 카드를 지칭하는 개념입니다. 예를 들어, 시작 대화 카드가 실행됐고 사용자의 답변을 기다리고 있다면 커서는 시작 대화 카드에 있습니다. 그리고 사용자가 '안녕'이라고 입력해 인사 대화 카드가 실행 됐다면 커서는 인사 대화 카드에 있습니다. 이 때, 인사 대화 카드가 실행되고 사용자의 답변을 기다리고 있습니다. 커서는 사용자가 답변을 입력했을 때 움직입니다.

### 대화 카드 간의 연결 2 - 대화 이동

대화 시나리오는 기본적으로  부모 대화 카드에서 자식 대화 카드로 진행됩니다. 만약 자식 대화 카드가 아닌 다른 대화카드로  이동하고 싶다면 어떻게 해야 할까요? 예를 들어, 플레이 아웃도어는 자사 제품의 특징을 설명해준 다음, 고객들이 제품을 구경할 수 있는 대화 시나리오를 만들려고 합니다. 이 때 **제품 소개 카드**는  **회사 특징 카드**와 부모 자식 관계가 아닙니다. 이럴 경우, 

1. **회사 특징 카드**의 자식으로 **제품소개이동 카드**를 만들고, 
2. **제품 소개 카드**로 *대화 이동*을 합니다. 
이제, 커서가 **회사 특징 카드**에 있을 때  제품 구매하로 가기 버튼을 클릭하면 **제품 소개 이동 카드**가 실행되면서 **제품 소개 카드**로 이동합니다.

*대화 이동*은 기본적으로 특정한 대화 시나리오를 재사용하기 위해 사용한다는 점을 기억하세요. **제품 소개 카드**는 시작 대화 카드에서 바로 접근할 수 있고, 회사 특징 카드를 거쳐 접근할 수도 있습니다. 즉, 각각의 제품 소개 시나리오를 만드는 것이 아니라 하나의 시나리오를 재사용 하고 있습니다.


----------

# 하루만에 챗봇 만들기(중급1)
지금부터는 대화 카드의 Advanced 모드에 대해 살펴보도록 하겠습니다. Advanced 모드는 사용자 입력을 다양하게 하고, 답변 전 실행 함수가 추가되었고, 챗봇 답변의 IF 기능과 대화 흐름 조절 기능이 추가되었습니다. 각각을 자세히 살펴보도록 하겠습니다.

핵심 개념 : 키워드, 엔터티, 인텐트, 타입, 정규식, 조건문, 변수저장
핵심 개념 : 변수접근, 조건문, 커서이동
핵심 개념 : 실행함수

## Step 1 사용자 입력

### 키워드(Keyword) - 인사 대화 카드
Normal 모드의 사용자 입력은 *키워드 방식*입니다. 키워드 방식이란 **사용자 입력**에 입력된 *키워드*를 사용자가 입력했을 경우에 해당 대화 카드가 실행되는 방식을 뜻합니다. 예를 들어, **사용자 입력**에 "여름 상의 면"과 같은 키워드가 입력되었을 경우 사용자가 해당 키워드가 모두 포함된 문장을 입력했을 시에 해당 대화 카드는 실행됩니다. 다른 예시로 **사용자 입력**에 "여름", "상의", "면"과 같은 키워드가 입력되었을 경우, 사용자가 해당 키워드 중 어느 하나라도 포함된 문장을 입력하면 해당 대화 카드는 실행됩니다. 
키워드 방식은 버튼형 챗봇과 같은 간단한 챗봇에는 적합할 수 있으나, 대화형 챗봇이나 고도화된 챗봇에는 적합하지 않을 수 있습니다. 예를 들어, 사용자가 "면으로 된 여름 상의 찾아줘"라고 입력했을 때 키워드 방식의 대화 카드는 실행될 수 있지만,  "더울 때 입는 면으로 된 윗도리 찾아줘"와 같이 같은 의미의 다른 문장을 입력했을 때 해당 대화 카드는 제대로 작동하지 않습니다. 같은 의미지만 다른 키워드를 사용했기 때문에 해당 대화 카드가 실행되지 않은 것입니다. 
 따라서 다양하게 표현할 수 있지만 의미는 같은 문장들을 동일하게 처리할 수 있는 방식이 필요합니다. 사용자 입력의 첫번째 기능인 인텐트를 알아보겠습니다. 

### 인텐트(#Intent) - 상의 대화 카드

인텐트는 의도를 뜻합니다. "면으로 된 여름 상의 찾아줘"와 "더울 때 입는 면으로 된 윗도리 찾아줘"는 같은 뜻 혹은 의도를 가졌다고 볼 수 있습니다. 이럴 경우, 두 문장을 하나의 인텐트로 처리할 수 있습니다. 따라서 **사용자 입력**을 인텐트로 입력하면 하나의 의도를 가진 여러가지 표현의 문장을 함께 처리할 수 있습니다. 즉, *검색 인텐트*를 만들어 위의 두 문장을 포함시키면 두 가지 문장을 하나의 인텐트로 처리할 수 있습니다.
중요한 점은 문장과 인텐트는 1:1대응으로 연결되어 있는 것이 아니라는 점입니다. 즉, 하나의 문장은 여러 인텐트에 속할 수 있습니다. 예를 들어,  "점퍼 갖고 싶어"의 경우 맥락에 따라 검색 인텐트일 수 있고, 구매 인텐트일 수도 있습니다. 이렇듯 어떤 문장이 어느 인텐트에 속하는지는 대화의 맥락에 따라 변할 수 있습니다.

### 엔터티(@Entity) - 상의 대화 카드

상의 대화 카드는 사용자가 상의를 구매하고 싶을 때 실행될 대화 카드입니다. 그런데 만약 사용자가 반팔티, 긴팔티, 외투, 점퍼  등 다양한 상의를 문의할 수 있고, 각각의 문의를 상의 대화 카드에서 같이 처리하고 싶다면 어떻게 해야될까요? 즉, 반팔티, 긴팔티, 외투, 점퍼 등을 하나의 개체로 인식하고 싶을 때는 엔터티를 사용할 수 있습니다.
한글로는 '개체명'이라고 번역할 수 있는데요, 단어가 어려워 이해하기 쉽진 않습니다. 그러나 반팔, 긴팔, 외투 등을 '상의'라는 엔터티로 묶는다와 같이, 예시를 통해 이해하면 쉬울 수 있습니다. 다른 예시로, 말, 고양이, 호랑이 등을 '동물'이라는 엔터티로 묶을 수도 있습니다. 즉, 다양한 각각의 개체들(말, 고양이, 호랑이)을 '개체명(동물)'으로 묶을 수 있습니다. 주의할 점은 어떤 단어가 개체가 될지 혹은 개체명이 될지는 정해져 있지 않다는 것입니다. 예를 들어, 고양이는 '동물'이라는 개체명에 속하는 개체이지만, 고양이가 개체명이 되어 그 개체로 샴 고양이, 뱅골 고양이 등이 묶일 수 있습니다. 따라서 쓰임새에 따라 어떤 개체명으로 어떤 개체를 묶을지, 즉 어떤 엔터티를 사용할지 결정해야 합니다. 

구체적으로 살펴보면 상의 대화 카드의 **사용자 입력**에는 @상의엔터티와 #검색 인텐트가 AND 조건으로 입력되어 있습니다. 이럴 경우, 상의 엔터티에 포함된 개체들과 검색 인텐트의 문장을 동시에 입력했을 때 해당 대화 카드가 실행됩니다. 예를 들어, "반팔티 찾아줘", "긴팔 찾아줘", "긴팔 검색해줘" 등 다양한 표현을 하나의 대화카드가 처리할 수 있습니다. 

### 정규식(/RegExr/) - 핸드폰 대화 카드

만약 사용자로부터 핸드폰 번호를 입력받고 싶을 땐 어떻게 해야할까요? **사용자 입력**에 '010-1234-1234'이라고 넣는다면 특정 핸드폰 번호만 부합합니다. 그렇다고 모든 핸드폰 번호를 입력 값에 입력할 수도 없습니다. 따라서 특정한 패턴의 숫자를 입력 받는 방법이 필요한데요, 이 때 사용할 수 있는 방법이 정규식(Regular Expression)으로 입력을 받는 것입니다.  즉, 010-1234-1234와 같은 특정한 패턴을 가리키는 정규식을 **사용자 입력**에 입력하면 사용자가 해당 타입을 입력할 때에만 대화 카드가 실행됩니다. 즉, 핸드폰 대화 카드의 **사용자 입력**이 /^\d{3}-\d{3,4}-\d{4}$/로 되어있기 때문에 해당 대화 카드가 실행되기 위해서는 사용자가 핸드폰 번호 형식을 입력해야만 합니다.
**사용자 입력**에서 정규식을 입력하고 싶다면 Advanced 모드에서 /를 입력하면 됩니다. 정규식에 익숙하지 않은 분들은 <a href= "regexr.com">regexr.com</a>을 참고하세요.

### 타입($Type) - 인증번호 확인 대화 카드

타입은 특정한 패턴을 읽는 정규식과 같은 기능을 제공합니다. 예를 들어 **사용자 입력**에서 $을 입력하면 미리 생성되어 있던 여러가지 타입들이 보이는데, 그 중 mobile을 선택하면 핸드폰 번호에 맞는 입력값만 받아들이게 됩니다. 이처럼 타입은 기본적으로 특정 패턴의 입력값을 받아들이는 기능을 합니다.

하지만 타입은 코드 레벨에서 조작이 가능하기 때문에 정규식보다 더 많은 일을 할 수 있습니다. 예를 들어, 핸드폰으로 전송된 인증번호와 사용자가 입력하는 번호가 일치하는지 여부는 정규식만으로 할 수 없습니다. 왜냐하면 정규식은 사용자 입력이 4자리라는 패턴은 읽을 수 있지만, 그 번호가 전송된 번호와 일치하는지는 알 수 없기 때문입니다. 따라서 전송된 번호와 사용자가 입력한 값이 일치하는지는 코드 차원에서 접근해야 합니다. 이럴 때 타입을 이용할 수 있습니다.

인증번호 확인 대화카드에서 $checkCode라는 타입을 만들어 보겠습니다. 그러면 default.js 파일 속에서 사용자가 입력한 값과 전송된 인증번호가 같은지 코드 레벨에서 처리 가능합니다.

### 조건문(IF) - 사용자 이름 대화 카드

대부분의 경우는 키워드, 엔터티, 인텐트, 정규식, 타입으로 **사용자 입력**을 원하는 방식으로 구성할 수 있습니다. 그러나 사용자의 입력값과 무관하게 해당 대화 카드가 실행되어야 하는 경우도 있습니다. 예를 들어, 사용자 이름을 **사용자 입력**으로 입력 받아야 하는 경우, 특정한 값이나 특정한 패턴으로 입력 받을 순 없습니다. 값이 정해져 있지 않을 뿐더러, 이름의 패턴은 전 세계적으로 다양하기 때문입니다. 따라서 사용자가 입력한 값이 무엇이든 사용자이름 대화카드는 실행되야 합니다. 이럴 때는 **사용자 입력**에 IF를 이용할 수 있습니다. 
**사용자 입력**에서 조건문을 입력하고 싶다면 Advanced 모드에서 if를 입력하고 () 안에 조건식을 입력하면 됩니다. 조건식의 결과값은 true나 false 둘 중 하나입니다. 사용자이름 대화카드처럼 if(true)라고 하면 항상 해당 카드는 실행된다고 볼 수 있습니다.
조건문은 if(true)처럼 단순한 방식으로 사용할 수도 있지만, 사용 의도에 따라 충분히 다양한 응용이 가능합니다. 예를 들어, 남자 사용자와 여자 사용자에 따라 다른 대답을 하고 싶은 때에도 if(gender == "male")과 같은 형식을 입력할 수 있습니다. 물론, gender와 같은 변수는 미리 설정되어 있어야 합니다. 

다음은 변수를 설정하는 법을 알아보도록 하겠습니다. 


### 변수(업데이트 예정. Next Sprint) - 이름 대화 카드

변수란 변하는 값을 의미합니다. 챗봇을 구축하다보면 단순히 정해진 값을 답변하는 경우가 아닌 계속해서 변하는 값을 답변해야 되는 경우가 생깁니다. 예를 들어, 챗봇이 사용자의 이름을 언급해야할 경우 단순히 정해진 값을 답변할 순 없습니다. 이럴 때 사용자의 이름을 물어보고 그 값을 변하는 값 즉, 변수에 저장할 필요가 있습니다. 이 때 변수 기능을 사용할 수 있습니다. 이름 대화 카드를 통해 구체적으로 살펴보겠습니다.
커서가 시작 대화 카드에 있을 때, "이름" 이라고 입력합니다. 챗봇이 "이름이 뭐예요?"라고 답변합니다. 이 때 사용자가 이름을 입력하면 그 입력값을 customerName이라는 변수에 저장하고 챗봇 답변에서 변수를 이용해 답변해 보겠습니다.

## Step 2 답변 전 실행 함수(Task)

*답변 전 실행 함수*는 해당 다이얼로그가 실행됐을 때, 챗봇이 답변을 사용자에게 보내기 전에 필요한 기능들을 처리하는 함수를 뜻합니다. 챗봇이 문자를 보내주거나, 음악을 틀어주거나, 집안의 조명기기를 조절하거나, 다른 기기와 소통하거나 데이터 베이스의 정보에 접근할 때 그 기능들을 수행하는 부분이 바로 이 부분입니다. 따라서 답변 전 실행 함수에서는 코드레벨에서 할 수 있는 다양한 일들을 할 수 있는 자바스크립트 코드가 들어갑니다. 

    var testTask = {
		action: function (task, context, callback) {
			//실제 비지니스 로직 코드가 들어가는 곳
		    callback(task, context);
		}
	};
	bot.setTask('testTask', testTask);

위의 자바스크립트 코드는 답변 전 실행 함수를 이루는 기본 구조를 보여줍니다. 기본적으로 변수를 지칭하는 var와 그 옆에 변수이름(testTask)이 쓰여 있습니다. 그리고 변수 testTask에는 JSON 형태의 자바스크립트 코드가 들어갑니다. 
실제 비지니스 로직 코드가 들어가는 곳에 원하는 기능들을 구현하면 됩니다.  action 함수에는 task, context, callback 3개의 매개 변수를 받습니다. 우선 callback은 비지니스 로직 코드가 끝나고 챗봇이 답변을 하도록 돌아가게 하는 명령어 정도로 이해하시면 될 것 같습니다.

중요한 매개 변수는 task와 context입니다. task에는 기본적으로 task에 대한 정보가 JSON형태로 들어 있습니다. 또한 task.buttons, task.image와 같은 형태로 **챗봇 답변**의 이미지, 버튼 내용을 조작할 수도 있습니다. <br/>
	
    task.buttons = [
	    {
		    text:"지도보기(클릭)", 
		    url: "http://map.naver.com/?query=" + context.bot.address
	    }
    ];

    task.image = {
	    url: context.bot.image
    };


context의 경우, 해당 대화 카드가 실행된 맥락에 관한 정보를 들고 있습니다. 예를 들어, 해당 챗봇에 대한 정보, 챗봇 사용자의 채널(소켓, 카카오, 페이스북 등), 사용자가 입력한 값, 사용자에 대한 식별값 등이 JSON 형태로 들어 있습니다. 

    context.bot = {
	    botName: "playchat",
	    description: "playchat 봇입니다."
	    commonButtons: [],
	    using: true,
		...   
    }
    
    context.channel = {
		name: "kakao",
		...
	}
    
    context.user = {
		userKey: "5a4d91842b7a1e41079c0d9a",
		...
	}
	
	context.dialog = {
		inNLP = "반갑다",
		inRaw = "반갑스무니다",
		inCurRaw = "반갑스무니다",
		...
	}

한 가지 주의할 점은 `context.dialog['key'] = 'value';`에 저장되는 값은 챗봇을 리빌드할 때 자동으로 사라진다는 점입니다. 따라서 챗봇을 리빌드해도 사라져서 안되는 정보는 `context.user['key'] = 'value';`에 저장해야 됩니다. 또한 	`context.user`에 있는 정보라 할지라도 서버를 재시작하면 사라집니다. 따라서 사라져서 안되는 정보는 데이터 베이스에 저장해 연동해야 됩니다. <br/>


### 이름 저장하기 - 사용자이름 대화카드

사용자이름 대화카드에서 saveCustomerName 이라는 답변 전 실행 함수(task)를 만듭니다. 

    var saveCustomerName = {
	    action: function (task,context,callback) {
		    if(context.user.customerName===undefined)
		    {
			    context.user.customerName='';
			    context.user.customerName=context.dialog.inCurRaw; 
		    }
		    callback(task,context);
		}
	};
	bot.setTask('saveCustomerName', saveCustomerName);

비지니스 로직 부분을 보면 자바스크립트 코드를 볼 수 있는데요. `context.user.customerName`의 값이 없으면 사용자의 입력값(`context.dialog.inCurRaw`)을 해당 값으로 저장합니다. 

다음 해당 값을 챗봇 답변에서 나타내기 위해서는 +변수이름+로 표현해줍니다. 예를 들어, +customerName+이라고 입력하면 해당 값을 답변에 출력합니다. 

### 외부 서버에 요청하기 1(크롤링) - 크롤링 대화카드

챗봇이 다양한 기능을 수행하기 위해서는 외부 서버에 있는 다양한 정보와 기능을 이용해야 합니다. 외부 서버의 자원을 이용하기 위해 크롤링실행 대화카드에서 crawling이라는 이름의 실행 함수를 만들 겠습니다. 그 다음 외부 서버에 요청하기 위해서 request.js 와 cheerio Module을 이용하겠습니다. `default.js`파일의 상단에 다음 문구를 추가합니다.

    var request = require('request');
    var cheerio = require('cheerio');

그리고 crawling 실행 함수의 비지니스 로직 영역에 다음의 코드를 추가 합니다.


    var url = 'http://finance.naver.com/item/main.nhn?code=035720';
    request(url, 
	    function (err, response, body) {
		    if(err)
		    {
		        console.log(err);
		    }
              var $ = cheerio.load(body);
              var selector = '#content > div.section.invest_trend > div:nth-child(2) > table > tbody > tr:nth-child(2) > td:nth-child(2) > em';
              var result = $(selector).text();

              context.dialog.crawlingResult = result;
              callback(task,context);
		}
	);

챗봇 답변에 +crawlingResult+ 를 입력하면 해당 값을 출력하게 됩니다. 

> 미션 1 : 대화 형태의 크롤링 구현하기. URL, Selector 사용자 입력을 받아 크롤링하기.

### 외부 서버에 요청하기 2 (API) - 네이버 대화카드

`var request = require('request')`는 추가되어 있어야 합니다. 네이버 대화카드에서 naverMovieSearch라는 실행 함수를 만들겠습니다. 그리고 다음의 코드를 비지니스 로직 영역에 넣습니다. 

        var client_id = 'tXRaAWut2_2R5OkcLpLQ';
        var client_secret = 'TaU4yqU4fI';
        var api_url = 'https://openapi.naver.com/v1/search/movie.json';
        var options = {
            method: "GET",
            url: api_url,
            headers: {'X-Naver-Client-Id':client_id, 'X-Naver-Client-Secret': client_secret},
            qs:
                {
                    query: '사건'
                }

        };
        request(options,
            function (err, response, body) {
                if(err)
                {
                    console.log(err);
                }
          		body = JSON.parse(body);
                context.dialog.movieData = [{title: 123}, {title: 432}];
                callback(task,context);
            }
        );

네이버에서 영화 검색을 하는 함수입니다. https://developers.naver.com에 접속해 어플리케이션을 등록하고 client_id와 client_secret 값을 받습니다. 그리고 API 설정에서 '검색'을 추가합니다. 그리고 Documents -> 서비스 API -> 검색 -> 영화로 들어와 API 호출에 대한 정보를 참고 합니다. 
네이버에서 전달받은 정보의 형태는 JSON형태입니다. 10개 이상의 영화가 전달 받은 데이터에 배열 형태로 담겨 있습니다. 챗봇 답변에서 배열 형태를 표현하기 위해서는 ###과 같은 문법을 사용합니다. 더 자세한 이야기는 챗봇 답변 파트에서 설명하겠습니다. 

> 미션 2 : 대화 형태의 Naver API 연동 구현하기. 


## Step 3 챗봇 답변

### 변수 접근(문자열) - 사용자이름 대화카드
**챗봇 답변**은 고정된 답변을 해줄 수도 있지만, 많은 경우 고객이 누구냐에 따라 그리고 고객의 의도에 따라 다양한 답변을 할 필요가 있습니다. 예를 들어, 사용자 이름을 입력 받았을 경우에도 해당 사용자의 이름을 언급할 필요가 있습니다. 이를 위해서 사용자이름 대화카드에서 사용자의 입력값을 `context.dialog.customerName`이라는 변수에 저장했습니다. 이렇게 저장된 변수값을 챗봇 답변에서 사용하고 싶을 경우 `context.dialog`를 뺀 나머지 변수명을 언급해주면 됩니다. 즉, `+customerName+`이라고 입력하면 됩니다.  예를 들어, 사용자이름 카드의 챗봇 답변에 '안녕하세요. 반가워요. +customerName+님'이라고 입력하겠습니다. 그리고 사용자이름 대화카드까지 대화를 이어나가 봅니다.

### 변수 접근(객체와 배열) - 네이버 대화카드
또한 변수에 들어있는 값이 사용자 이름과 같이 단순한 문자열이 아닐 수도 있습니다. 예를 들어, 변수가 자바스크립트 객체이거나 배열일 수 있습니다. 객체의 경우에는 자바스크립트와 동일하게 .key 의 형태로 해당 키(key)에 해당하는 값에 접근할 수 있습니다. 또한 변수가 배열일 경우, ###와 같은 문법을 통해 배열을 for문처럼 접근할 수 있습니다. <br/>
예를 들어, 위의 Naver API 연동 구현에서 movieData는 배열입니다. 이럴경우, #movieData#와 같이 표현하면 movieData 배열의 각 아이템에 접근하는 것이 됩니다. #movieData# 뒤부터는 각 아이템에 해당하는 key를 통해 해당하는 값에 접근할 수 있습니다. 그리고 하나의 아이템에 대한 접근이 끝났을 경우 #을 붙여줘 끝을 명시해줍니다. 결론적으로 #배열#각 아이템# 형태의 문법입니다. 이 때, 각 아이템 내에서는 +key값+와 같은 형태로 각 아이템의 key와 해당하는 값에 접근할 수 있습니다. 또한 +index+는 각 아이템별로 해당 인덱스 값을 자동으로 반환해줍니다.

### IF (조건에 따른 챗봇답변) - 사랑해 대화카드
**사용자 입력**에서 if의 사용법을 알아봤습니다. **챗봇 답변**에도 동일한 if 기능을 이용할 수 있습니다. 하나의 대화카드에서 조건에 따라 다른 답변을 내놓을 수 있는 기능입니다. 초급 강의에서 채봇 답변을 여러개 등록 했을 시에 무작위로 챗봇 답변이 선택된다고 말씀드렸습니다. 만약 복수의 챗봇 답변을 등록하고 IF에 조건을 집어 넣으면 조건에 해당되는 챗봇 답변이 실행됩니다. 
사랑해 대화카드를 살펴보면 IF 안에 `context.user.customerName`라고 입력되어 있습니다. `customerName`이라는 변수의 값이 존재하면 해당 챗봇답변을 실행하고, 값이 존재하지 않으면 다른 챗봇 답변을 실행하는 구조입니다. 따라서 사용자이름 대화카드에서 이름을 입력한 경우에만 해당 챗봇답변이 실행됩니다. 

이러한 구조는 차후 설명한 배포 채널과 관련 깊습니다. 카카오, 페이스북, 네이버 톡톡 등과 같이 다양한 채널을 하나의 챗봇으로 배포하기 위해서는 각각의 채널에 맞는 형식으로 배포해야 합니다. 따라서 `IF(context.channel.name == 'kakao')`일 때, <br/>
`IF(context.channel.name == 'facebook')`일 때, <br/>
`IF(context.channel.name == 'navertalk')`일 때, <br/>
등과 같이 해당 채널에 따라 챗봇 답변을 다르게 해야 합니다. 


### 대화 흐름 조절(업데이트 예정. Next Sprint)
대화 흐름 조절에서는 초급에서 배웠던 대화 이동 이외에 대화 흐름을 조절하는 다양한 방법을 알아보겠습니다. 


 - 대화이동 (제품소개이동 대화카드)

먼저 초급에서 살펴보았던 **대화이동**이 있습니다. 대화 이동의 경우,  이동 후 대화 카드의 실행함수가 실행되고  이동 전 대화 카드의 텍스트가 출력됩니다. 그리고 커서는 이동 후 대화카드를 가리킵니다.

 - 다시 질문하기 (핸드폰번호재질의 대화카드)

**다시 질문하기**는 사용자의 입력값에 부합하는 자식 대화 카드가 없을 때 커서가 이동하지 않고 다시 챗봇 답변을 하는 기능입니다. 예를 들어, 핸드폰 대화카드에서 챗봇 답변으로 '번호를 입력하세요'라고 했습니다. 이 때 사용자가 핸드폰 번호 형식이 아닌 엉뚱한 답변을 할 경우, 사용자의 입력값에 부합하는 자식 대화 카드가 없습니다. 따라서 챗봇은 '알아듣지 못했습니다'를 출력합니다. 하지만 핸드폰 대화 카드의 막내 대화카드로 **사용자 입력**에는 if(true)를, **챗봇 답변**에는 **다시 질문하기**를 설정하면 사용자의 입력값에 부합하는 자식 대화 카드가 없을 때, 핸드폰 재질의 카드가 실행되면서 커서는 핸드폰 대화카드에 남아있습니다. 그리고 핸드폰 재질의 카드의 텍스트를 출력합니다. 핸드폰 재질의 카드의 챗봇 답변에 '핸드폰 번호 형식에 맞게 다시 한 번 입력해주세요.'라고 입력하면 결과적으로 재질의하는 효과를 가져옵니다. 이처럼 재질의 기능은 주로 사용자 입력에 if(true)와 같이 사용되어 막내 대화카드에 위치합니다. 결국 부모로 대화이동하는 기능이 재질의 기능입니다.

 - 이전 대화이동

**이전 대화이동**은 주로 대화상에서 '이전'이라고 입력했을 때 이전 대화 카드로 이동하는 기능을 말합니다. '이전'이라고 말했을 때 기본적으로 이전 대화카드로 이동하는 것은 *공통 대화 시나리오* 기능으로 구현된 것입니다. 여기서 주의할 점은 '이전 대화이동' 기능이 있는 대화카드가 실행됐을 경우, 해당 대화카드를 기준으로 2단계 부모(조부모) 카드로 커서가 이동한다는 것입니다.

 - 대화이동 후 검색
 
**대화이동 후 검색**은 대화이동 후 이동한 대화카드의 자식들의 사용자 입력을 검색하는 기능입니다. 예를 들어, 회사특징 카드에 커서가 있을 때 '여름 검색'이라고 입력하면 상의이동후검색 대화카드가 실행됩니다. 이 때, 상의로 대화이동 후 검색 기능이 실행되어 상의 대화카드에 커서가 있는 상태에서 '여름 검색'으로 검색이 실행됩니다. 따라서 상의 대화카드의 자식 카드들의 사용자 입력에서 '여름 검색'을 찾습니다. 부합하는 사용자 입력이 있을 시 해당 자식 카드가 실행되고 없을 경우, '답변을 알아들을 수 없습니다'로 답변합니다. 

 - 돌아가기용 대화이동 / 돌아가기

**돌아가기용 대화이동**은 대화이동과 동일하게 작동합니다. 다만 대화이동한 후 특정 대화 카드에서 돌아가기 기능을 실행했을 시, 돌아가기용 대화이동을 실행했던 대화 카드의 부모 카드로 커서가 이동합니다. 


> 미션3 : 핸드폰 인증 챗봇 만들기.



# 일주일만에 챗봇 만들기(중급2)

## Step 1 답변 전 실행 함수 (개발자 중심)

## Step 2 기획 (모듈형 챗봇, 채널 이해, 뎁스 줄이기)

## Step 3 실전 챗봇 개발 실습

## Step 4 배포하기

### 카카오 배포하기

### 페이스북 배포하기

### 네이버 톡톡 배포하기

### 라인 배포하기

### 위챗 배포하기

### 핸드폰 배포하기


# 한달만에 챗봇 만들기(고급1)

## step 1 대화셋 딥 러닝 연계

## step 2 시나리오 딥 러닝 연계
